#version 460
#pragma shader_stage(compute)
#extension GL_EXT_shader_image_load_formatted: enable

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0) restrict uniform image2D i_dst;

layout(push_constant) uniform Constants {
	uint FrameCounter;
} C;

const float Pi = 3.14159265359;

#define Color vec3
#define Point vec3
#define Vector vec3

struct Ray {
	Point origin;
	Vector direction;
};

struct Sphere {
	Point center;
	float radius;
};

struct Intersection {
	float t;
	Point position;
	Vector normal;
};

Point rayAt(Ray ray, float t) {
	return ray.origin + ray.direction * t;
}

Color skyColor(Ray ray) {
	Vector ndir = normalize(ray.direction);
	float t = 0.5 * (ndir.z + 1.0);
	return (1.0 - t) * Color(1.0, 1.0, 1.0) + t * Color(0.5, 0.7, 1.0);
}

Intersection raySphereIntersect(Ray ray, Sphere sphere) {
	Point oc = ray.origin - sphere.center;
	float a = dot(ray.direction, ray.direction);
	float half_b = dot(oc, ray.direction);
	float c = dot(oc, oc) - sphere.radius * sphere.radius;
	float discriminant = half_b * half_b - a * c;

	Intersection result;
	if (discriminant < 0) {
		result.t = -1;
	} else {
		result.t = (-half_b - sqrt(discriminant)) / a;
		result.position = rayAt(ray, result.t);
		result.normal = normalize(result.position - sphere.center);
	}
	return result;
}

const uint SphereCount = 2;
const Sphere Spheres[SphereCount] = {
	{{0, -1,      0}, 0.5},
	{{0, -1, -100.5}, 100}
};

// https://github.com/LWJGL/lwjgl3-demos/blob/main/res/org/lwjgl/demo/opengl/raytracing/randomCommon.glsl
vec3 randomHemispherePoint(vec3 n, vec2 rand) {
	float ang1 = (rand.x + 1.0) * Pi; // [-1..1) -> [0..2*PI)
	float u = rand.y; // [-1..1), cos and acos(2v-1) cancel each other out, so we arrive at [-1..1)
	float u2 = u * u;
	float sqrt1MinusU2 = sqrt(1.0 - u2);
	float x = sqrt1MinusU2 * cos(ang1);
	float y = sqrt1MinusU2 * sin(ang1);
	float z = u;
	vec3 v = vec3(x, y, z);
	return v * sign(dot(v, n));
}

uvec3 pcg3d(uvec3 v) {
	v = v * 1664525u + 1013904223u;
	v.x += v.y * v.z;
	v.y += v.z * v.x;
	v.z += v.x * v.y;
	v ^= v >> 16u;
	v.x += v.y * v.z;
	v.y += v.z * v.x;
	v.z += v.x * v.y;
	return v;
}

vec3 random3(vec3 f) {
	return uintBitsToFloat((pcg3d(floatBitsToUint(f)) & 0x007FFFFFu) | 0x3F800000u) - 1.0;
}

vec2 randvec2(uint s) {
	return random3(vec3(gl_GlobalInvocationID.xy + ivec2(s), C.FrameCounter)).xy;
}

Color traceRay(Ray ray, uint maxDepth, uint sampleId) {

	Color color = {1, 1, 1};
	for (uint i = 0; i < maxDepth; i += 1) {
		// Find closest hit
		Intersection closestHit;
		closestHit.t = -1;
		for (uint i = 0; i < SphereCount; i += 1) {
			Intersection intersection = raySphereIntersect(ray, Spheres[i]);
			if (intersection.t >= 0 && (intersection.t < closestHit.t || closestHit.t < 0))
			closestHit = intersection;
		}

		// Return or spawn secondary ray
		if (closestHit.t >= 0) {
			if (i == maxDepth - 1) {
				color = Color(0);
				break;
			}
			color *= 0.5;
			ray = Ray(
				closestHit.position + closestHit.normal * 0.0001,
				randomHemispherePoint(closestHit.normal, randvec2(i + sampleId * maxDepth))
			);
		} else {
			color *= skyColor(ray);
			break;
		}
	}
	return color;
}

void main() {
	// Input
	const uvec2 Gid = gl_GlobalInvocationID.xy;

	// Output
	const uvec2 DstSize = uvec2(imageSize(i_dst));
	const float AspectRatio = float(DstSize.x) / float(DstSize.y);

	// Bounds check
	if (any(greaterThanEqual(Gid, DstSize))) return;

	// Viewport
	const float ViewportHeight = 2;
	const float ViewportWidth = ViewportHeight * AspectRatio;
	const vec2 ViewportSize = {ViewportWidth, ViewportHeight};
	const float FocalLength = 1;

	// Camera
	const Point Camera = {0, 0, 0};
	const Vector HorizontalSpan = {ViewportSize.x, 0, 0};
	const Vector VerticalSpan = {0, 0, ViewportSize.y};
	const Point LowerLeftCorner = Camera - HorizontalSpan / 2 - VerticalSpan / 2 - Point(0, FocalLength, 0);

	// Camera ray
	vec2 uv = (vec2(Gid) + 0.5) / (DstSize - 1);
	uv.y = 1.0 - uv.y;
	Ray ray = {Camera, LowerLeftCorner + uv.x * HorizontalSpan + uv.y * VerticalSpan};

	// Shading
	Color colorOut = {0, 0, 0};
	const uint MaxBounces = 16;
	const uint Samples = 64;
	for (uint i = 0; i < Samples; i += 1)
		colorOut += traceRay(ray, MaxBounces, i);
	colorOut /= Samples;

	// Write output
	colorOut = sqrt(colorOut);
	imageStore(i_dst, ivec2(Gid), vec4(colorOut, 1));
}
