#version 460
#pragma shader_stage(compute)
#extension GL_EXT_shader_image_load_formatted: enable

#include "intersect.glsl"
#include "random.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0) restrict uniform image2D i_dst;

layout(push_constant) uniform Constants {
	mat4 View;
	uint FrameCounter;
} C;

const uint SphereCount = 2;
const Sphere Spheres[SphereCount] = {
	{{0, -1,      0}, 0.5, {0.2, 0.7, 0.0}},
	{{0, -1, -100.5}, 100, {0.2, 0.2, 0.2}}
};

vec3 skyColor(Ray ray) {
	vec3 ndir = normalize(ray.direction);
	float t = 0.5 * (ndir.z + 1.0);
	return (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);
}

vec3 traceRay(Ray ray, uint maxDepth, inout uint rngState) {

	vec3 color = {1, 1, 1};
	for (uint i = 0; i < maxDepth; i += 1) {
		// Find closest hit
		Intersection closestHit;
		closestHit.t = -1;
		for (uint i = 0; i < SphereCount; i += 1) {
			Intersection intersection = raySphereIntersect(ray, Spheres[i]);
			if (intersection.t >= 0 && (intersection.t < closestHit.t || closestHit.t < 0))
			closestHit = intersection;
		}

		// Return or spawn secondary ray
		if (closestHit.t >= 0) {
			if (i == maxDepth - 1) {
				color = vec3(0);
				break;
			}
			color *= closestHit.albedo;
			ray = Ray(
				closestHit.position + closestHit.normal * 0.0001,
				closestHit.normal + randomSpherePoint(vec3(randomFloat(rngState), randomFloat(rngState), randomFloat(rngState)) * 2.0 - 1.0)
			);
		} else {
			color *= skyColor(ray);
			break;
		}
	}
	return color;
}

void main() {
	// Input
	const uvec2 Gid = gl_GlobalInvocationID.xy;
	uint rngState = (Gid.x * 1973 + Gid.y * 9277 + C.FrameCounter * 26699) | 1;

	// Output
	const uvec2 DstSize = uvec2(imageSize(i_dst));
	const float AspectRatio = float(DstSize.x) / float(DstSize.y);

	// Bounds check
	if (any(greaterThanEqual(Gid, DstSize))) return;

	// Viewport
	const float ViewportHeight = 2;
	const float ViewportWidth = ViewportHeight * AspectRatio;
	const vec2 ViewportSize = {ViewportWidth, ViewportHeight};
	const float FocalLength = 2;

	// Camera
	const vec3 HorizontalSpan = {ViewportSize.x, 0, 0};
	const vec3 VerticalSpan = {0, 0, ViewportSize.y};
	const vec3 LowerLeftCorner = vec3(0) - HorizontalSpan / 2 - VerticalSpan / 2 - vec3(0, FocalLength, 0);

	// Starting ray
	const vec2 Pitch = vec2(1.0) / vec2(DstSize - 1);
	vec2 uv = (vec2(Gid) + 0.5) * Pitch;
	uv.y = 1.0 - uv.y;

	// Rendering
	const uint Samples = 32;
	const uint MaxBounces = 4;
	vec3 colorOut = {0, 0, 0};
	for (uint i = 0; i < Samples; i += 1) {
		// Camera ray
		vec2 randomOffset = {randomFloat(rngState), randomFloat(rngState)};
		vec2 suv = uv + (randomOffset - 0.5) * Pitch;
		Ray ray = {vec3(0), LowerLeftCorner + suv.x * HorizontalSpan + suv.y * VerticalSpan};
		ray.origin = (C.View * vec4(ray.origin, 1)).xyz;
		ray.direction = (C.View * vec4(ray.direction, 0)).xyz;
		colorOut += tonemap(traceRay(ray, MaxBounces, rngState));
	}
	colorOut /= Samples;

	// Write output
	imageStore(i_dst, ivec2(Gid), vec4(tonemapInvert(colorOut), 1));
}
