#version 460
#pragma shader_stage(compute)
#extension GL_EXT_shader_image_load_formatted: enable

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0) restrict uniform image2D i_dst;

layout(push_constant) uniform Constants {
	uint FrameCounter;
} C;

const float Pi = 3.14159265359;

#define Color vec3
#define Point vec3
#define Vector vec3

struct Ray {
	Point origin;
	Vector direction;
};

struct Sphere {
	Point center;
	float radius;
};

struct Intersection {
	float t;
	Point position;
	Vector normal;
};

Point rayAt(Ray ray, float t) {
	return ray.origin + ray.direction * t;
}

Color skyColor(Ray ray) {
	Vector ndir = normalize(ray.direction);
	float t = 0.5 * (ndir.z + 1.0);
	return (1.0 - t) * Color(1.0, 1.0, 1.0) + t * Color(0.5, 0.7, 1.0);
}

Intersection raySphereIntersect(Ray ray, Sphere sphere) {
	Point oc = ray.origin - sphere.center;
	float a = dot(ray.direction, ray.direction);
	float half_b = dot(oc, ray.direction);
	float c = dot(oc, oc) - sphere.radius * sphere.radius;
	float discriminant = half_b * half_b - a * c;

	Intersection result;
	if (discriminant < 0) {
		result.t = -1;
	} else {
		result.t = (-half_b - sqrt(discriminant)) / a;
		result.position = rayAt(ray, result.t);
		result.normal = normalize(result.position - sphere.center);
	}
	return result;
}

const uint SphereCount = 2;
const Sphere Spheres[SphereCount] = {
	{{0, -1,      0}, 0.5},
	{{0, -1, -100.5}, 100}
};

// https://github.com/LWJGL/lwjgl3-demos/blob/main/res/org/lwjgl/demo/opengl/raytracing/randomCommon.glsl
vec3 randomSpherePoint(vec3 rand) {
	float ang1 = (rand.x + 1.0) * Pi; // [-1..1) -> [0..2*PI)
	float u = rand.y; // [-1..1), cos and acos(2v-1) cancel each other out, so we arrive at [-1..1)
	float u2 = u * u;
	float sqrt1MinusU2 = sqrt(1.0 - u2);
	float x = sqrt1MinusU2 * cos(ang1);
	float y = sqrt1MinusU2 * sin(ang1);
	float z = u;
	return vec3(x, y, z);
}

const vec3 RandomScale3 = {0.1031, 0.1030, 0.0973};

vec2 random2(vec2 p) {
	vec3 p3 = fract(p.xyx * RandomScale3);
	p3 += dot(p3, p3.yzx + 19.19);
	return fract((p3.xx+p3.yz)*p3.zy);
}

vec3 random3(vec3 p) {
	p = fract(p * RandomScale3);
	p += dot(p, p.yxz+19.19);
	return fract((p.xxy + p.yzz)*p.zyx);
}

Color traceRay(Ray ray, uint maxDepth, uint sampleId) {

	Color color = {1, 1, 1};
	for (uint i = 0; i < maxDepth; i += 1) {
		// Find closest hit
		Intersection closestHit;
		closestHit.t = -1;
		for (uint i = 0; i < SphereCount; i += 1) {
			Intersection intersection = raySphereIntersect(ray, Spheres[i]);
			if (intersection.t >= 0 && (intersection.t < closestHit.t || closestHit.t < 0))
			closestHit = intersection;
		}

		// Return or spawn secondary ray
		if (closestHit.t >= 0) {
			if (i == maxDepth - 1) {
				color = Color(0);
				break;
			}
			color *= 0.5;
			ray = Ray(
				closestHit.position + closestHit.normal * 0.0001,
				closestHit.normal + randomSpherePoint(random3(vec3(gl_GlobalInvocationID.x * sampleId, gl_GlobalInvocationID.y * sampleId, C.FrameCounter)))
			);
		} else {
			color *= skyColor(ray);
			break;
		}
	}
	return color;
}

void main() {
	// Input
	const uvec2 Gid = gl_GlobalInvocationID.xy;

	// Output
	const uvec2 DstSize = uvec2(imageSize(i_dst));
	const float AspectRatio = float(DstSize.x) / float(DstSize.y);

	// Bounds check
	if (any(greaterThanEqual(Gid, DstSize))) return;

	// Viewport
	const float ViewportHeight = 2;
	const float ViewportWidth = ViewportHeight * AspectRatio;
	const vec2 ViewportSize = {ViewportWidth, ViewportHeight};
	const float FocalLength = 1;

	// Camera
	const Point Camera = {0, 0, 0};
	const Vector HorizontalSpan = {ViewportSize.x, 0, 0};
	const Vector VerticalSpan = {0, 0, ViewportSize.y};
	const Point LowerLeftCorner = Camera - HorizontalSpan / 2 - VerticalSpan / 2 - Point(0, FocalLength, 0);

	// Starting ray
	const vec2 Pitch = vec2(1.0) / vec2(DstSize - 1);
	vec2 uv = (vec2(Gid) + 0.5) * Pitch;
	uv.y = 1.0 - uv.y;

	// Rendering
	const uint Samples = 32;
	const uint MaxBounces = 16;
	Color colorOut = {0, 0, 0};
	for (uint i = 0; i < Samples; i += 1) {
		// Camera ray
		vec2 suv = uv + (random2(fract(uv * vec2(i + C.FrameCounter, C.FrameCounter))) - 0.5) * Pitch;
		Ray ray = {Camera, LowerLeftCorner + suv.x * HorizontalSpan + suv.y * VerticalSpan};
		colorOut += traceRay(ray, MaxBounces, i);
	}
	colorOut /= Samples;

	// Write output
	colorOut = sqrt(colorOut);
	imageStore(i_dst, ivec2(Gid), vec4(colorOut, 1));
}
